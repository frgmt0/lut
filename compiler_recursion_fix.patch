diff --git a/src/compiler.rs b/src/compiler.rs
index xxxx..xxxx 100644
--- a/src/compiler.rs
+++ b/src/compiler.rs
@@ -235,7 +235,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
                     let function_type = self.i64_type.fn_type(&param_types, false);
                     // Create the function 
                     let linkage = if *is_public {
-                        inkwell::module::Linkage::External
+                        inkwell::module::Linkage::ExternalLinkage
                     } else {
-                        inkwell::module::Linkage::Private
+                        inkwell::module::Linkage::PrivateLinkage
                     };
                     let function = self.module.add_function(name, function_type, Some(linkage));
@@ -255,9 +255,9 @@ impl<'ctx> LLVMCompiler<'ctx> {
                     
                     // Create the function (just declaration for now)
                     let linkage = if *is_public {
-                        inkwell::module::Linkage::External
+                        inkwell::module::Linkage::ExternalLinkage
                     } else {
-                        inkwell::module::Linkage::Private
+                        inkwell::module::Linkage::PrivateLinkage
                     };
                     
                     let function = self.module.add_function(name, function_type, Some(linkage));
@@ -293,7 +293,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
                     
                     // If no return statement was found, add a default return of 0
                     if !self.builder.get_insert_block().unwrap().get_terminator().is_some() {
-                        let return_value = self.i64_type.const_int(0, false);
+                        let return_value = self.i64_type.const_int(0, false); 
                         self.builder.build_return(Some(&return_value)).unwrap();
                     }
                     
@@ -339,7 +339,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
                     let i32_type = self.context.i32_type();
                     let return_value = i32_type.const_int(0, false);
                     self.builder.build_return(Some(&return_value)).unwrap();
+                }
+             }
-                }
-            }
         }
         
         // Create the main function for the program entry point
@@ -396,9 +396,9 @@ impl<'ctx> LLVMCompiler<'ctx> {
             
             // Create the function
             let linkage = if is_public {
-                inkwell::module::Linkage::External
+                inkwell::module::Linkage::ExternalLinkage
             } else {
-                inkwell::module::Linkage::Private
+                inkwell::module::Linkage::PrivateLinkage
             };
             
             let new_function = self.module.add_function(&name, function_type, Some(linkage));
@@ -411,10 +411,11 @@ impl<'ctx> LLVMCompiler<'ctx> {
         
         // Create entry block
         let entry_block = self.context.append_basic_block(function, "entry");
-        self.builder.position_at_end(entry_block);
-        
         // Save current function
         let old_function = self.current_function;
+
+        // Position at entry block after saving old function
+        self.builder.position_at_end(entry_block);
         self.current_function = Some(function);
         
         // Store parameters in local variables
@@ -425,7 +426,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
                 let alloca = self.create_entry_block_alloca(&param.name);
                 
                 // Store the parameter value in the local variable
-                self.builder.build_store(alloca, param_value).unwrap();
+                self.builder.build_store(alloca, param_value).unwrap(); 
                 
                 // Save old variable with the same name if it exists
                 if let Some(old_ptr) = self.variables.get(&param.name) {
@@ -443,6 +444,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
         // Compile function body
         for stmt in body {
             self.compile_statement(stmt)?;
+            // Check if this statement added a terminator
+            if self.builder.get_insert_block().unwrap().get_terminator().is_some() {
+                break;  // Already have a terminator, don't add more code after this
+            }
         }
         
         // If no return statement was found, add a default return of 0
         if !self.builder.get_insert_block().unwrap().get_terminator().is_some() {
-            let return_value = self.i64_type.const_int(0, false);
+            let return_value = self.i64_type.const_int(0, false); 
             self.builder.build_return(Some(&return_value)).unwrap();
         }
         
@@ -1078,15 +1078,15 @@ impl<'ctx> LLVMCompiler<'ctx> {
                 
                 // Clone the function reference to avoid borrowing issues
                 let function_clone = if let Some(function) = self.functions.get(&name) {
-                    *function
+                    *function 
                 } else {
                     return Err(format!("Undefined function: {}", name));
                 };
                 
                 // Compile the arguments
                 let mut compiled_args = Vec::with_capacity(arguments.len());
                 for arg in arguments {
-                    let compiled_arg = self.compile_expression(arg)?;
+                    let compiled_arg = self.compile_expression(arg)? 
                     compiled_args.push(compiled_arg.into());
                 }
                 
@@ -1198,7 +1198,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
                         match self.variable_types.get(&var_name) {
                             Some(VariableType::Integer) | Some(VariableType::Boolean) | Some(VariableType::Float) => {
                                 // Load as integer value (float is treated as integer for now)
-                                let int_load = self.builder.build_load(self.i64_type, ptr_val, &format!("{}_int", var_name)).unwrap();
+                                let int_load = self.builder.build_load(self.i64_type, ptr_val, &var_name).unwrap();
                                 Ok(int_load)
                             },
                             Some(VariableType::String) => {
@@ -1908,7 +1908,7 @@ impl<'ctx> LLVMCompiler<'ctx> {
     }
     
     // Helper to create an i64 alloca instruction in the entry block
-    fn create_entry_block_alloca(&self, name: &str) -> PointerValue<'ctx> {
+    fn create_entry_block_alloca(&self, name: &str) -> PointerValue<'ctx> {
         let func = self.builder.get_insert_block().unwrap().get_parent().unwrap();
         let entry = func.get_first_basic_block().unwrap();
         
@@ -1916,14 +1916,14 @@ impl<'ctx> LLVMCompiler<'ctx> {
             Some(first_instr) => {
                 let builder = self.context.create_builder();
                 builder.position_before(&first_instr);
-                builder.build_alloca(self.i64_type, name).unwrap()
+                let alloca = builder.build_alloca(self.i64_type, name).unwrap();
+                alloca
             }
             None => {
                 let current_block = self.builder.get_insert_block().unwrap();
                 let builder = self.context.create_builder();
                 builder.position_at_end(entry);
-                let alloca = builder.build_alloca(self.i64_type, name).unwrap();
+                let alloca = builder.build_alloca(self.i64_type, name).unwrap();
                 self.builder.position_at_end(current_block);
                 alloca
             }